import{isValidObjectId as k}from"mongoose";var j={schemaTypeError:{"zh-CN":'\u53C2\u6570 "schema" \u7684\u7C7B\u578B\u5F97\u662F "Schema"\u3002',"en-US":'param "schema" type must be "Schema".'},modelCountError:{"zh-CN":"\u94A9\u5B50\u51FD\u6570\u8BBF\u95EE\u5230\u7684 Model \u6570\u91CF\u4E3A 0 \u6216\u8005\u4E0D\u5B58\u5728\u3002","en-US":"The number of models accessed is 0 or does not exist."}};function O(h){if(h in j){let f=j[h];return(process.env.LANG??"").match("CN")?f["zh-CN"]:f["en-US"]}}function E(h){if(h.constructor.name!=="Schema")throw new Error(O("schemaTypeError"));h.pre(["find","findOne"],async function(f){let u=this.model.db.models;if(Object.keys(u??{}).length===0)throw new Error(O("modelCountError"));let d=this.model.schema;function y(n){let s="";if(n?.instance==="ObjectID"){let t=n.options;t?.ref?.length&&(s=t.ref)}else if(n?.$embeddedSchemaType)return y(n.$embeddedSchemaType);return u[s]}function g(n,s=d){let t=[];for(;n.length>0;){let r=n.shift()??"";if(s.path([...t,r].join(".")))t.push(r);else{let a=y(s.path(t.join(".")));if(a){let e=g([r,...n],a.schema);if(n.length)t.push(...e);else return[t.join("."),...e]}else return[...t,r]}}return t}function b(n,s=".",t=""){let r={};for(let[a,e]of Object.entries(n)){let i=t?`${t}${s}${a}`:a;if(e.constructor===Object&&!Object.keys(e).some(c=>c.startsWith("$"))){let c=b(e,s,i);r={...r,...c}}else r[i]=e}return r}async function m(n,s,t=d){if(typeof s!="object"||s===null||Object.keys(s).length===0)return s;let r={},a=t.path(n.join("."));for(let[e,i]of Object.entries(s)){if(!d.path(e)){let o=[...g(e.split(".")),i].reduceRight((l,p)=>p==="$"?l:{[p]:l});[[e,i]]=Object.entries(o)}let c=e.startsWith("$")?e==="$"?n:[]:[...n,e],w=c.join("."),$=t.path(w);if(!e.startsWith("$")&&$===void 0){let o=y(a);if(o){let l=await m([],i,o.schema);if(l)return{$in:(await o.find(b({[e]:l}),"_id")).map(S=>S._id)}}}Array.isArray(i)?Object.assign(r,{[e]:await Promise.all(i.map(async o=>await m(c,o,t)))}):typeof i=="object"&&i!==null&&Object.keys(i).length>0&&!k(i)?Object.assign(r,{[e]:Object.fromEntries(await Promise.all(Object.entries(i).map(async([o,l])=>Object.entries(await m(c,{[o]:l},t))[0])))}):r[e]=i}return r}this._conditions=await m([],this._conditions),f()})}export{E as MongooseFindByReference};
//# sourceMappingURL=main.mjs.map