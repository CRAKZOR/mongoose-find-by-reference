{"version":3,"sources":["../src/main.ts"],"sourcesContent":["import { Schema, Model, SchemaType, isValidObjectId } from \"mongoose\";\r\n\r\nconst messages: Record<string, any> = {\r\n  schemaTypeError: {\r\n    \"zh-CN\": '参数 \"schema\" 的类型得是 \"Schema\"。',\r\n    \"en-US\": 'param \"schema\" type must be \"Schema\".',\r\n  },\r\n  modelCountError: {\r\n    \"zh-CN\": \"钩子函数访问到的 Model 数量为 0 或者不存在。\",\r\n    \"en-US\": \"The number of models accessed is 0 or does not exist.\",\r\n  },\r\n};\r\n\r\n/**\r\n * 翻译//函数\r\n */\r\nfunction i18n(messageId: string) {\r\n  if (messageId in messages) {\r\n    const message = messages[messageId];\r\n    const lang = (process.env.LANG ?? \"\").match(\"CN\");\r\n    if (lang) return message[\"zh-CN\"];\r\n    else return message[\"en-US\"];\r\n  }\r\n}\r\n\r\nexport function MongooseFindByReference(schema: Schema) {\r\n  // 假设得到的不是 Schema 则报错\r\n  if (schema.constructor.name !== \"Schema\")\r\n    throw new Error(i18n(\"schemaTypeError\"));\r\n\r\n  // 对 Schema 挂上钩子\r\n  schema.pre([\"find\", \"findOne\", \"distinct\"], async function (next) {\r\n    /** 当前的 Model 们 */\r\n    const models = this.model.db.models;\r\n\r\n    // 对  Models 进行判空\r\n    if (Object.keys(models ?? {}).length === 0)\r\n      throw new Error(i18n(\"modelCountError\"));\r\n\r\n    /** 当前的 Schema */\r\n    const schema: Schema = this.model.schema;\r\n\r\n    /**\r\n     * 返回 Ref Path 关联的 Model。\r\n     * Return the Model which conntected with Ref Path.\r\n     * @param obj\r\n     * @returns\r\n     */\r\n    function getModel(obj: SchemaType): Model<any> | undefined {\r\n      let refKey = \"\";\r\n      if (obj?.instance === \"ObjectID\") {\r\n        // 假设是 Ref Path 就直接读取\r\n        const options = obj.options;\r\n        if (options?.ref?.length) refKey = options.ref;\r\n        // else if (options?.refPath?.length)\r\n        //   if (schema.path(options.refPath)) return { refPath: options.refPath };\r\n      } else if ((obj as any)?.$embeddedSchemaType) {\r\n        // 假设是数组就读取子项 Type\r\n        return getModel((obj as any).$embeddedSchemaType);\r\n      }\r\n      return models[refKey];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param paths\r\n     *\r\n     * @exmples ['owner','name','en-US']  => ['owner', 'name.en-US']\r\n     */\r\n    function transPath2RefPath(\r\n      paths: string[],\r\n      tSchema: Schema = schema\r\n    ): string[] {\r\n      let previousPath: string[] = [];\r\n      while (paths.length > 0) {\r\n        const path = paths.shift() ?? \"\";\r\n        if (tSchema.path([...previousPath, path].join(\".\"))) {\r\n          previousPath.push(path);\r\n        } else {\r\n          const currentModel = getModel(tSchema.path(previousPath.join(\".\")));\r\n          if (currentModel) {\r\n            const recurseResult = transPath2RefPath([path, ...paths], currentModel.schema)\r\n            if (!paths.length) {\r\n              return [ previousPath.join(\".\"), ...recurseResult ];\r\n            } else {\r\n              previousPath.push(...recurseResult);\r\n            }\r\n          } else return [...previousPath, path];\r\n        }\r\n      }\r\n      return previousPath;\r\n    }\r\n\r\n    `{\r\n        $and:{\r\n            'owner.name':'Dean',\r\n            'infos.timestamp.createdAt':Date,\r\n        },\r\n        $or:[]\r\n    }`;\r\n\r\n    type Dict = { [key: string]: any };\r\n    function flatten(dd: Dict, separator: string = '.', prefix: string = ''): Dict {\r\n      // transform nested object to dot notation\r\n      `\r\n        { person: { name: \"John\" } } to { \"person.name\": \"John\" }\r\n      `\r\n      let result: Dict = {};\r\n\r\n      for (let [k, v] of Object.entries(dd)) {\r\n          let key = prefix ? `${prefix}${separator}${k}` : k;\r\n\r\n          if (v.constructor === Object && !Object.keys(v).some( checkKey => checkKey.startsWith('$'))) {\r\n              let flatObject = flatten(v as Dict, separator, key);\r\n              result = { ...result, ...flatObject };\r\n          } else {\r\n              result[key] = v;\r\n          }\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    async function lookup(\r\n      prevPaths: string[],\r\n      conditions: Record<string, any>,\r\n      cSchema = schema\r\n    ): Promise<any> {\r\n      // 如果 Conditions 不能进行分析就直接返回它\r\n      if (\r\n        typeof conditions !== \"object\" ||\r\n        conditions === null ||\r\n        Object.keys(conditions).length === 0\r\n      ) {\r\n        return conditions;\r\n      }\r\n\r\n      /** 最终结果 */\r\n      const result: Record<string, any> = {};\r\n\r\n      // 获取前一个 Path 的值\r\n      const prevPathsValue = cSchema.path(prevPaths.join(\".\"));\r\n\r\n      for (let [paths, value] of Object.entries(conditions)) {\r\n        // paths 1 = 'owner.name.en'; value 1 = 'Dean'\r\n\r\n        // 判断 Paths 存在于 Schema 上\r\n        if (schema.path(paths)) {\r\n        } else {\r\n          const reduceResult = [\r\n            ...transPath2RefPath(paths.split(\".\")),\r\n            value as any,\r\n          ].reduceRight((previousValue, currentValue) =>\r\n            currentValue === \"$\"\r\n              ? previousValue\r\n              : { [currentValue]: previousValue }\r\n          );\r\n          [[paths, value]] = Object.entries(reduceResult);\r\n        }\r\n\r\n        // 当前的 Paths 数组\r\n        const currentPathsArray = paths.startsWith(\"$\")\r\n          ? paths === \"$\"\r\n            ? prevPaths\r\n            : []\r\n          : [...prevPaths, paths];\r\n\r\n        // 当前的 Paths\r\n        const currentPathsString = currentPathsArray.join(\".\");\r\n\r\n        // 当前的 Paths 对应的值\r\n        const currentPathsValue = cSchema.path(currentPathsString);\r\n\r\n        if (!paths.startsWith(\"$\"))\r\n          if (currentPathsValue === undefined) {\r\n            const currentModel = getModel(prevPathsValue);\r\n            if (currentModel) {\r\n              const subCoditions = await lookup([], value, currentModel.schema);\r\n              if (subCoditions) {\r\n                const ids = (\r\n                  await currentModel.find(flatten({[paths]: subCoditions}), \"_id\")\r\n                ).map((v) => v._id);\r\n\r\n                return { $in: ids };\r\n              }\r\n            }\r\n          }\r\n\r\n        if (Array.isArray(value))\r\n          Object.assign(result, {\r\n            [paths]: await Promise.all(\r\n              value.map(\r\n                async (v) => await lookup(currentPathsArray, v, cSchema)\r\n              )\r\n            ),\r\n          });\r\n        else if (\r\n          typeof value === \"object\" &&\r\n          value !== null &&\r\n          Object.keys(value).length > 0 &&\r\n          !isValidObjectId(value)\r\n        )\r\n          Object.assign(result, {\r\n            [paths]: Object.fromEntries(\r\n              await Promise.all(\r\n                Object.entries(value).map(\r\n                  async ([k, v]) =>\r\n                    Object.entries(\r\n                      await lookup(\r\n                        currentPathsArray,\r\n                        {\r\n                          [k]: v,\r\n                        },\r\n                        cSchema\r\n                      )\r\n                    )[0]\r\n                )\r\n              )\r\n            ),\r\n          });\r\n        else result[paths] = value;\r\n      }\r\n      return result;\r\n    }\r\n    (this as any)._conditions = await lookup([], (this as any)._conditions);\r\n    next();\r\n  });\r\n}\r\n"],"mappings":"AAAA,OAAoC,mBAAAA,MAAuB,WAE3D,IAAMC,EAAgC,CACpC,gBAAiB,CACf,QAAS,sEACT,QAAS,uCACX,EACA,gBAAiB,CACf,QAAS,mHACT,QAAS,uDACX,CACF,EAKA,SAASC,EAAKC,EAAmB,CAC/B,GAAIA,KAAaF,EAAU,CACzB,IAAMG,EAAUH,EAASE,CAAS,EAElC,OADc,QAAQ,IAAI,MAAQ,IAAI,MAAM,IAAI,EAC/BC,EAAQ,OAAO,EACpBA,EAAQ,OAAO,EAE/B,CAEO,SAASC,EAAwBC,EAAgB,CAEtD,GAAIA,EAAO,YAAY,OAAS,SAC9B,MAAM,IAAI,MAAMJ,EAAK,iBAAiB,CAAC,EAGzCI,EAAO,IAAI,CAAC,OAAQ,UAAW,UAAU,EAAG,eAAgBC,EAAM,CAEhE,IAAMC,EAAS,KAAK,MAAM,GAAG,OAG7B,GAAI,OAAO,KAAKA,GAAU,CAAC,CAAC,EAAE,SAAW,EACvC,MAAM,IAAI,MAAMN,EAAK,iBAAiB,CAAC,EAGzC,IAAMI,EAAiB,KAAK,MAAM,OAQlC,SAASG,EAASC,EAAyC,CACzD,IAAIC,EAAS,GACb,GAAID,GAAK,WAAa,WAAY,CAEhC,IAAME,EAAUF,EAAI,QAChBE,GAAS,KAAK,SAAQD,EAASC,EAAQ,aAGjCF,GAAa,oBAEvB,OAAOD,EAAUC,EAAY,mBAAmB,EAElD,OAAOF,EAAOG,CAAM,CACtB,CAQA,SAASE,EACPC,EACAC,EAAkBT,EACR,CACV,IAAIU,EAAyB,CAAC,EAC9B,KAAOF,EAAM,OAAS,GAAG,CACvB,IAAMG,EAAOH,EAAM,MAAM,GAAK,GAC9B,GAAIC,EAAQ,KAAK,CAAC,GAAGC,EAAcC,CAAI,EAAE,KAAK,GAAG,CAAC,EAChDD,EAAa,KAAKC,CAAI,MACjB,CACL,IAAMC,EAAeT,EAASM,EAAQ,KAAKC,EAAa,KAAK,GAAG,CAAC,CAAC,EAClE,GAAIE,EAAc,CAChB,IAAMC,EAAgBN,EAAkB,CAACI,EAAM,GAAGH,CAAK,EAAGI,EAAa,MAAM,EAC7E,GAAKJ,EAAM,OAGTE,EAAa,KAAK,GAAGG,CAAa,MAFlC,OAAO,CAAEH,EAAa,KAAK,GAAG,EAAG,GAAGG,CAAc,MAI/C,OAAO,CAAC,GAAGH,EAAcC,CAAI,GAGxC,OAAOD,CACT,CAWA,SAASI,EAAQC,EAAUC,EAAoB,IAAKC,EAAiB,GAAU,CAK7E,IAAIC,EAAe,CAAC,EAEpB,OAAS,CAACC,EAAGC,CAAC,IAAK,OAAO,QAAQL,CAAE,EAAG,CACnC,IAAIM,EAAMJ,EAAS,GAAGA,IAASD,IAAYG,IAAMA,EAEjD,GAAIC,EAAE,cAAgB,QAAU,CAAC,OAAO,KAAKA,CAAC,EAAE,KAAME,GAAYA,EAAS,WAAW,GAAG,CAAC,EAAG,CACzF,IAAIC,EAAaT,EAAQM,EAAWJ,EAAWK,CAAG,EAClDH,EAAS,CAAE,GAAGA,EAAQ,GAAGK,CAAW,OAEpCL,EAAOG,CAAG,EAAID,EAItB,OAAOF,CACT,CAEA,eAAeM,EACbC,EACAC,EACAC,EAAU3B,EACI,CAEd,GACE,OAAO0B,GAAe,UACtBA,IAAe,MACf,OAAO,KAAKA,CAAU,EAAE,SAAW,EAEnC,OAAOA,EAIT,IAAMR,EAA8B,CAAC,EAG/BU,EAAiBD,EAAQ,KAAKF,EAAU,KAAK,GAAG,CAAC,EAEvD,OAAS,CAACjB,EAAOqB,CAAK,IAAK,OAAO,QAAQH,CAAU,EAAG,CAIrD,GAAI,CAAA1B,EAAO,KAAKQ,CAAK,EACd,CACL,IAAMsB,EAAe,CACnB,GAAGvB,EAAkBC,EAAM,MAAM,GAAG,CAAC,EACrCqB,CACF,EAAE,YAAY,CAACE,EAAeC,IAC5BA,IAAiB,IACbD,EACA,CAAE,CAACC,CAAY,EAAGD,CAAc,CACtC,EACA,CAAC,CAACvB,EAAOqB,CAAK,CAAC,EAAI,OAAO,QAAQC,CAAY,EAIhD,IAAMG,EAAoBzB,EAAM,WAAW,GAAG,EAC1CA,IAAU,IACRiB,EACA,CAAC,EACH,CAAC,GAAGA,EAAWjB,CAAK,EAGlB0B,EAAqBD,EAAkB,KAAK,GAAG,EAG/CE,EAAoBR,EAAQ,KAAKO,CAAkB,EAEzD,GAAI,CAAC1B,EAAM,WAAW,GAAG,GACnB2B,IAAsB,OAAW,CACnC,IAAMvB,EAAeT,EAASyB,CAAc,EAC5C,GAAIhB,EAAc,CAChB,IAAMwB,EAAe,MAAMZ,EAAO,CAAC,EAAGK,EAAOjB,EAAa,MAAM,EAChE,GAAIwB,EAKF,MAAO,CAAE,KAHP,MAAMxB,EAAa,KAAKE,EAAQ,CAAC,CAACN,CAAK,EAAG4B,CAAY,CAAC,EAAG,KAAK,GAC/D,IAAKhB,GAAMA,EAAE,GAAG,CAEA,GAKtB,MAAM,QAAQS,CAAK,EACrB,OAAO,OAAOX,EAAQ,CACpB,CAACV,CAAK,EAAG,MAAM,QAAQ,IACrBqB,EAAM,IACJ,MAAOT,GAAM,MAAMI,EAAOS,EAAmBb,EAAGO,CAAO,CACzD,CACF,CACF,CAAC,EAED,OAAOE,GAAU,UACjBA,IAAU,MACV,OAAO,KAAKA,CAAK,EAAE,OAAS,GAC5B,CAACnC,EAAgBmC,CAAK,EAEtB,OAAO,OAAOX,EAAQ,CACpB,CAACV,CAAK,EAAG,OAAO,YACd,MAAM,QAAQ,IACZ,OAAO,QAAQqB,CAAK,EAAE,IACpB,MAAO,CAACV,EAAGC,CAAC,IACV,OAAO,QACL,MAAMI,EACJS,EACA,CACE,CAACd,CAAC,EAAGC,CACP,EACAO,CACF,CACF,EAAE,CAAC,CACP,CACF,CACF,CACF,CAAC,EACET,EAAOV,CAAK,EAAIqB,EAEvB,OAAOX,CACT,CACC,KAAa,YAAc,MAAMM,EAAO,CAAC,EAAI,KAAa,WAAW,EACtEvB,EAAK,CACP,CAAC,CACH","names":["isValidObjectId","messages","i18n","messageId","message","MongooseFindByReference","schema","next","models","getModel","obj","refKey","options","transPath2RefPath","paths","tSchema","previousPath","path","currentModel","recurseResult","flatten","dd","separator","prefix","result","k","v","key","checkKey","flatObject","lookup","prevPaths","conditions","cSchema","prevPathsValue","value","reduceResult","previousValue","currentValue","currentPathsArray","currentPathsString","currentPathsValue","subCoditions"]}